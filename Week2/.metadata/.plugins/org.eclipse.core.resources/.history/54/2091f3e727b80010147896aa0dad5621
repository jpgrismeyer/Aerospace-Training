#include "hts221.h"

/* helpers */
static HAL_StatusTypeDef _rd(HTS221_t *d, uint8_t reg, uint8_t *buf, uint16_t n){
  return HAL_I2C_Mem_Read(d->hi2c, (d->addr7b<<1), reg, I2C_MEMADD_SIZE_8BIT, buf, n, 100);
}
static HAL_StatusTypeDef _wr_u8(HTS221_t *d, uint8_t reg, uint8_t val){
  return HAL_I2C_Mem_Write(d->hi2c, (d->addr7b<<1), reg, I2C_MEMADD_SIZE_8BIT, &val, 1, 100);
}
static int16_t s16(uint8_t lo, uint8_t hi){ return (int16_t)((hi<<8) | lo); }

HAL_StatusTypeDef HTS221_ReadWhoAmI(HTS221_t *d, uint8_t *who){
  return _rd(d, HTS221_REG_WHO_AM_I, who, 1);
}

HAL_StatusTypeDef HTS221_InitPowerOn(HTS221_t *d){
  uint8_t who=0;
  if (HTS221_ReadWhoAmI(d, &who)!=HAL_OK || who!=HTS221_WHO_AM_I_VAL) return HAL_ERROR;
  uint8_t ctrl1 = (1u<<7) | (1u<<2) | (1u<<0);   // PD=1, BDU=1, ODR=1Hz
  HAL_StatusTypeDef st = _wr_u8(d, HTS221_REG_CTRL1, ctrl1);
  if (st != HAL_OK) return st;
  HAL_Delay(5);
  return HAL_OK;
}
// --- Temperatura (Â°C) ---
HAL_StatusTypeDef HTS221_ReadTemperatureDegC(HTS221_t *d, float *t_degC)
{
  uint8_t T0_l, T1_l, msb, buf[2];
  if (_rd(d, 0x32, &T0_l, 1)!=HAL_OK) return HAL_ERROR;   // T0_degC_x8
  if (_rd(d, 0x33, &T1_l, 1)!=HAL_OK) return HAL_ERROR;   // T1_degC_x8
  if (_rd(d, 0x35, &msb,  1)!=HAL_OK) return HAL_ERROR;   // T1_T0_MSB

  uint16_t T0_x8 = ((msb & 0x03) << 8) | T0_l;            // bits 1:0
  uint16_t T1_x8 = ((msb & 0x0C) << 6) | T1_l;            // bits 3:2
  float T0 = T0_x8 / 8.0f;
  float T1 = T1_x8 / 8.0f;

  if (_rd(d, 0x3C, buf, 2)!=HAL_OK) return HAL_ERROR;     // T0_OUT_L/H
  int16_t T0_OUT = (int16_t)((buf[1]<<8)|buf[0]);
  if (_rd(d, 0x3E, buf, 2)!=HAL_OK) return HAL_ERROR;     // T1_OUT_L/H
  int16_t T1_OUT = (int16_t)((buf[1]<<8)|buf[0]);

  if (_rd(d, 0x2A, buf, 2)!=HAL_OK) return HAL_ERROR;     // TEMP_OUT_L/H
  int16_t T_OUT = (int16_t)((buf[1]<<8)|buf[0]);

  *t_degC = T0 + ((float)(T_OUT - T0_OUT) * (T1 - T0)) / (float)(T1_OUT - T0_OUT);
  return HAL_OK;
}

// --- Humedad (%RH) ---
HAL_StatusTypeDef HTS221_ReadHumidityRH(HTS221_t *d, float *rh)
{
  uint8_t H0_x2, H1_x2, buf[2];
  if (_rd(d, 0x30, &H0_x2, 1)!=HAL_OK) return HAL_ERROR;  // H0_rH_x2
  if (_rd(d, 0x31, &H1_x2, 1)!=HAL_OK) return HAL_ERROR;  // H1_rH_x2
  float H0 = H0_x2 / 2.0f;
  float H1 = H1_x2 / 2.0f;

  if (_rd(d, 0x36, buf, 2)!=HAL_OK) return HAL_ERROR;     // H0_T0_OUT_L/H
  int16_t H0_OUT = (int16_t)((buf[1]<<8)|buf[0]);
  if (_rd(d, 0x3A, buf, 2)!=HAL_OK) return HAL_ERROR;     // H1_T0_OUT_L/H
  int16_t H1_OUT = (int16_t)((buf[1]<<8)|buf[0]);

  if (_rd(d, 0x28, buf, 2)!=HAL_OK) return HAL_ERROR;     // HUM_OUT_L/H
  int16_t H_OUT = (int16_t)((buf[1]<<8)|buf[0]);

  float rh_lin = H0 + ((float)(H_OUT - H0_OUT) * (H1 - H0)) / (float)(H1_OUT - H0_OUT);
  if (rh_lin < 0.0f)   rh_lin = 0.0f;
  if (rh_lin > 100.0f) rh_lin = 100.0f;
  *rh = rh_lin;
  return HAL_OK;
}
/* ... y las funciones de temperatura/humedad que te pasÃ©, sin cambiar la firma ... */
