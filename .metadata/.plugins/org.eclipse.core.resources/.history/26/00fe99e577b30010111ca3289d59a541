/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdbool.h>

#include "stm32l47xx.h"
#include "stm32l475xx_gpio_driver.h"
#include "stm32l47xx_i2c_driver.h"

#define LED_GPIO_PORT   GPIOB
#define LED_PIN         14

// Dirección 7-bit del HTS221 (datasheet)
#define HTS221_ADDR_7BIT     0x5F
#define HTS221_REG_WHO_AM_I  0x0F
#define HTS221_WHO_AM_I_VAL  0xBC

static void delay_busy(volatile uint32_t ticks)
{
    while (ticks--) {
        _asm_("nop");
    }
}

static void LED_Init_User(void)
{
    GPIO_Handle_t LedHandle;

    LedHandle.pGPIOx = LED_GPIO_PORT;
    LedHandle.GPIO_PinConfig.GPIO_PinNumber      = LED_PIN;
    LedHandle.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_OUT;
    LedHandle.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_SPEED_LOW;
    LedHandle.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    LedHandle.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OP_TYPE_PP;
    LedHandle.GPIO_PinConfig.GPIO_PinAltFunMode  = 0;

    GPIO_Init(&LedHandle);
}

static void LED_BlinkPattern_OK(void)
{
    // patrón "OK": blink rápido 2 veces, pausa larga
    GPIO_ToggleOutputPin(LED_GPIO_PORT, LED_PIN);
    delay_busy(50000);
    GPIO_ToggleOutputPin(LED_GPIO_PORT, LED_PIN);
    delay_busy(50000);

    GPIO_ToggleOutputPin(LED_GPIO_PORT, LED_PIN);
    delay_busy(50000);
    GPIO_ToggleOutputPin(LED_GPIO_PORT, LED_PIN);
    delay_busy(200000); // pausa larga
}

static void LED_BlinkPattern_FAIL(void)
{
    // patrón "FAIL": blink lento constante
    GPIO_ToggleOutputPin(LED_GPIO_PORT, LED_PIN);
    delay_busy(300000);
}

static uint8_t I2C_ReadReg_1byte(I2C_RegDef_t *I2C, uint8_t devAddr7, uint8_t regAddr)
{
    uint8_t value = 0;

    // Paso 1: mandar el address del registro (WRITE, sin STOP final -> repeated start)
    I2C_MasterSendData(I2C,
                       &regAddr,
                       1,
                       devAddr7,
                       /Sr=/1);  // Sr=1 -> queremos hacer repeated start después

    // Paso 2: leer 1 byte del esclavo (READ con STOP al final)
    I2C_MasterReceiveData(I2C,
                          &value,
                          1,
                          devAddr7,
                          /Sr=/0); // Sr=0 -> STOP al final

    return value;
}

int main(void)
{
    // 1. LED init
    LED_Init_User();

    // 2. Blink rápido 3 veces = "arranqué firmware"
    for (int i = 0; i < 3; i++) {
        GPIO_ToggleOutputPin(LED_GPIO_PORT, LED_PIN);
        delay_busy(50000);
        GPIO_ToggleOutputPin(LED_GPIO_PORT, LED_PIN);
        delay_busy(50000);
    }

    // 3. Init I2C2
    I2C_Handle_t I2C2Handle;
    I2C2Handle.pI2Cx = I2C2;
    I2C_Init(&I2C2Handle);
    // Hasta acá ya sabemos que no se cuelga (lo vimos en la prueba anterior)

    // 4. Intentar leer WHO_AM_I del HTS221 (0x0F)
    uint8_t whoami = I2C_ReadReg_1byte(I2C2, HTS221_ADDR_7BIT, HTS221_REG_WHO_AM_I);

    // 5. Bucle infinito con patrón según resultado:
    while (1)
    {
        if (whoami == HTS221_WHO_AM_I_VAL)
        {
            // sensor respondió bien: patrón OK
            LED_BlinkPattern_OK();
        }
        else
        {
            // sensor no respondió lo esperado: patrón FAIL
            LED_BlinkPattern_FAIL();
        }
    }
}
